/* n皇后
Problem Description
象棋棋盘可以分成 N×N个格子，在该象棋盘中放置 N个皇后，要求每行、列及每条对角线上仅有一只皇后 。由于在棋盘的每行，应该有且仅有一个棋子，所以一个放置N个皇后的方案可用N个数字来描述，其中第i个数字表示第i行的皇后所在的列位置。请找出以字典序排列的前三个可行方案，以及所有可行方案的总数。
Input
第一行为一个整数t，表示测试样例的个数
每一个测试样例输入一行，只有一个整数N，表示棋盘的大小（6≤N≤13）。
Output
每个测试样例输出四行。
前三行为按照字典顺序排列的前三个可行方案，每一行包括n个右空格分隔的整数。注意：行首和行尾不能有空格。
第四行为可行方案的总数。
Sample Input

2
6
8

Sample Output

2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
1 5 8 6 3 7 2 4
1 6 8 3 7 4 2 5
1 7 4 6 8 2 5 3
92 */

#include <cmath>
#include <cstring>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

int n;
int x[14]={0};
int map[24][14] = {{2, 4, 6, 1, 3, 5},{3, 6, 2, 5, 1, 4},{4, 1, 5, 2, 6, 3},
				{1 ,3 ,5 ,7 ,2 ,4 ,6},{1 ,4 ,7 ,3 ,6 ,2 ,5},{1 ,5 ,2 ,6 ,3 ,7 ,4},
				{1 ,5 ,8 ,6 ,3 ,7 ,2 ,4},{1 ,6 ,8 ,3 ,7 ,4 ,2 ,5},{1 ,7 ,4 ,6 ,8 ,2 ,5 ,3},
				{1 ,3 ,6 ,8 ,2 ,4 ,9 ,7 ,5},{1 ,3 ,7 ,2 ,8 ,5 ,9 ,4 ,6},{1 ,3 ,8 ,6 ,9 ,2 ,5 ,7 ,4},
				{1 ,3 ,6 ,8 ,10 ,5 ,9 ,2 ,4 ,7},{1 ,3 ,6 ,9 ,7 ,10 ,4 ,2 ,5 ,8},{1 ,3 ,6 ,9 ,7 ,10 ,4 ,2 ,8 ,5},
				{1 ,3 ,5 ,7 ,9 ,11 ,2 ,4 ,6 ,8 ,10},{1 ,3 ,6 ,9 ,2 ,8 ,11 ,4 ,7 ,5 ,10},{1 ,3 ,7 ,9 ,4 ,2 ,10 ,6 ,11 ,5 ,8},
				{1 ,3 ,5 ,8 ,10 ,12 ,6 ,11 ,2 ,7 ,9 ,4},{1 ,3 ,5 ,10 ,8 ,11 ,2 ,12 ,6 ,9 ,7 ,4},{1 ,3 ,5 ,10 ,8 ,11 ,2 ,12 ,7 ,9 ,4 ,6},
				{1 ,3 ,5 ,2 ,9 ,12 ,10 ,13 ,4 ,6 ,8 ,11 ,7},{1 ,3 ,5 ,7 ,9 ,11 ,13 ,2 ,4 ,6 ,8 ,10 ,12},{1 ,3 ,5 ,7 ,12 ,10 ,13 ,6 ,4 ,2 ,8 ,11 ,9}};
int cnt = 0;
int cntZ[8] = {4, 40, 92, 352, 724, 2680, 14200, 73712};
int num = 0;

bool place(int k){
	for(int i=1; i<k; i++)
		if(abs(x[k]-x[i])==abs(k-i) || x[k]==x[i])
			return false;
	return true;	
}

int queen(int t){
	if(t>n){
		cnt++;	
		if(cnt<4) {
			for(int i=1; i<n+1; i++)
				map[num][i] = x[i];
			num++;
		}
	}
	else {
		for(int i=1; i<n+1; i++){
			x[t] = i;
			if(place(t))
				queen(t+1);
		}
	}
}

int main(){
   	int t;
   	
//   	for(int i=6; i<=13; i++) {
//   		n = i;
//        cnt = 0;
//   		queen(1);
//		cntZ[i-6] = cnt;			
//	}
//   	
//   	cin>>t;
//   	while(t--) {
//   		cin>>n;
//		for(int i=0; i<3; i++) {
//			for(int j=1; j<n; j++)
//				cout<<map[(n-6)*3+i][j]<<" ";
//			cout<<map[(n-6)*3+i][n]<<endl;
//		}
//		cout<<cntZ[n-6]<<endl;
//	}
    cin>>t;
	while(t--) {
		cin>>n;
		for(int i=0; i<3; i++) {
			for(int j=0; j<n-1; j++)
				cout<<map[(n-6)*3+i][j]<<" ";
			cout<<map[(n-6)*3+i][n-1]<<endl;
		}
		cout<<cntZ[n-6]<<endl;
	} 
    return 0;
}
